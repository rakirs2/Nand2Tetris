# Boolean Arithmetic

This chapter is dedicated to "how computers count". For starters, we just need to define basic calculations.

## 2.1 Operations
- Add
- subtract
- sign conversions ( going from + to - and vice versa)
- comparisons
- multiplication
- division

## 2.2 Binary number representations

- look at the "general notes" for representing binary

### Fixed word size
If you've ever heard of computers being "8 bit or 16 bit," it generally refers to the limitations of the words size.

One of the fundamental questions about computers is how do we take a "word size" and convert it into something meaningful for humans.

- How do we represent positive and negative (and 0)
- How do we represent decimals

A question you should ask is what is the implication of a large vs a small word size and if you've ever heard of 32 and 64 bit architectures/problems caused by them.

### 2.3 Binary Addition arithmetic

- used example in the book of (1 0 0 1 + 0 1 0 1)
- Overflow example ( 1 0 1 1 + 0 1 1 1)

### 2.4 Signed Binary Numbers
An n-bit binary system can code 2<sup>n</sup> different things.


## Glossary

### Arithmetic Logic Unit - ALU

### Central Processing Unit - CPU

### Least Significant Bits (LSB) - bits with least value (right most)

### Memory Address - reference to a specific piece of information on a computer

### Most Significant BIts (MSB) - bits of the highest value (left most)

### Overflow - when the result of an operation requires more data than the word size

### nbit - any number bit binary number

### radix complement

### word size - the number of bits that a computer sues to represent a bit of information

